<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Cracking the PM Interview: How to Land a Product Manager Job in Technology</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="filepos829727" class="calibre_10"><span class="calibre2"><span class="bold">Solutions</span></span></p><p class="calibre_11">All solutions will be implemented with Java. If you don’t know Java, that’s okay. We’ll try to keep our code free of complex Java syntax so that you can focus on the main algorithm.</p><blockquote class="calibre_23">Note: Programming code can be difficult to read on a Kindle's narrow screen, since it causes line breaks in the wrong places. If your Kindle support landscape mode, you might want to try that. (This is supported with the Kindle Paperwhite.) Otherwise, try reading it on the desktop app (resize the app to have a larger page size and increase the words per line).</blockquote><p class="calibre_63"><span class="calibre4"><span class="bold">16.1</span></span><span class="calibre4"> Given a sorted array of positive integers with an empty spot (zero) at the end, insert an element in sorted order. </span><a id="filepos830673"></a></p><p class="calibre_64"><a href="index_split_108.html#filepos767574"><span class="italic">jump to question</span></a></p><p class="calibre_51">We can imagine that our array looks something like this (with a blank spot at the end):</p><blockquote class="calibre_23"><span class="calibre6"><tt class="calibre10">1 4 7 8 9 _</tt></span></blockquote><p class="calibre_31">If we need to insert an element like 6, we can’t just insert it at the end. We are supposed to put it in order.</p><blockquote class="calibre_23"><span class="calibre6"><tt class="calibre10">1 4 6 7 8 9</tt></span></blockquote><p class="calibre_31">This requires “shifting” all elements down to make space for 6 and then inserting it.</p><p class="calibre_1">There are two ways of approaching this problem.</p><p class="calibre_1"><span class="calibre4"><span class="bold">Approach 1: Shift From Back, Then Insert</span></span></p><p class="calibre_14">The first approach is to shift all the elements over and then insert the value x. We have to be careful though to not overwrite values as we’re inserting.</p><p class="calibre_1">Instead of shifting from the front, we can shift from the back moving forwards.</p><blockquote class="calibre_23"><span class="calibre6"><tt class="calibre10">1 4 7 8 9 _</tt></span></blockquote><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><p class="calibre_31">We would first copy 9 into the empty spot. Then 8 into where 9 was. Then 7 into where 8 was, and so on. When we find the appropriate spot for x, we stop and insert x.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">boolean insert(int[] array, int x) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Make sure input is valid.*/</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">   if (array[array.length - 1] != 0 || x &lt;= 0) {</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">     return false;</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="6" class="calibre_60"><br class="calibre1"/></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Start from last non-blank element, moving left and copying elements one by one. Stop when we’ve found the right spot for x or when we’ve hit the beginning of the array.*/</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">   int index = array.length - 2; // start from 2nd to last</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">   while (index &gt;= 0 &amp;&amp; array[index] &gt; x) {</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">     // shift over by one</tt></span><br class="calibre1"/></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">     array[index + 1] = array[index]; </tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">     </tt></span><br class="calibre1"/></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">     // move to next element</tt></span><br class="calibre1"/></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">     index = index - 1; </tt></span></li><li value="15" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="16" class="calibre_60"><br class="calibre1"/></li><li value="17" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Insert element wherever the above loop stopped.*/</tt></span></li><li value="18" class="calibre_60"><span class="calibre5"><tt class="calibre10">   array[index + 1] = x;</tt></span></li><li value="19" class="calibre_60"><br class="calibre1"/></li><li value="20" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return true;</tt></span></li><li value="21" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">We return true if we could insert the element or false if there was an error.</p><p class="calibre_1"><span class="calibre4"><span class="bold">Approach 2: Swap Elements Moving Forward</span></span></p><p class="calibre_14">Alternatively, we could iterate forwards through the array. For the initial elements in the array (the ones that are less than x), we don’t do anything. Those won’t be moved.</p><p class="calibre_1">However, when we find where x should be inserted, we swap x and the current element in the array. The value of x will now equal the old element in the array.</p><p class="calibre_1">When we get to the next element, we want to swap x for that value. We continue doing this for each element in the array until we get to the end.</p><blockquote class="calibre_23"><span class="calibre6"><tt class="calibre10">insert 6 into 2, 3, 7, 8, 9, _</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">set x = 6</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">start i at A[0]</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">move i to A[1]</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">move i to A[2]</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">swap A[2] and x.</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">   A = {2, 3, </tt></span><span class="calibre6"><tt class="calibre10"><span class="underline">6</span></tt></span><span class="calibre6"><tt class="calibre10">, 8, 9, _}</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">   x = 7</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">swap A[3] and x.</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">   A = {2, 3, 6, </tt></span><span class="calibre6"><tt class="calibre10"><span class="underline">7</span></tt></span><span class="calibre6"><tt class="calibre10">, 9, _}</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">   x = 8</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">swap A[4] and x.</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">   A = {2, 3, 6, 7, </tt></span><span class="calibre6"><tt class="calibre10"><span class="underline">8</span></tt></span><span class="calibre6"><tt class="calibre10">, _}</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">   x = 9</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">swap A[5] and x.</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">   A = {2, 3, 6, 7, 8, </tt></span><span class="calibre6"><tt class="calibre10"><span class="underline">9</span></tt></span><span class="calibre6"><tt class="calibre10">}</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">   x = _</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6">   </span><br class="calibre1"/></blockquote><p class="calibre_31">The following code implements this algorithm.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">boolean insert(int[] array, int x) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Make sure input is valid.*/</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">   if (array[array.length - 1] != 0 || x &lt;= 0) {</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">     return false;</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="6" class="calibre_60"><br class="calibre1"/></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">   for (int i = 0; i &lt; array.length; i++) {</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">     if (x &lt; array[i] || array[i] == 0) {</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">        /* Swap x and array[i].*/</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">        int temp = array[i];</tt></span></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">        array[i] = x;</tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">        x = temp;</tt></span></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="15" class="calibre_60"><br class="calibre1"/></li><li value="16" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return true;</tt></span></li><li value="17" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">Note that once the if statement on line 8 becomes true, it will always be true.</p><p class="calibre_1">Both algorithms will take O(N) time.</p><p class="calibre_30"><span class="calibre4"><span class="bold">16.2</span></span><span class="calibre4"> Reverse the order of elements in an array (without creating a new array). </span><a id="filepos840470"></a></p><p class="calibre_64"><a href="index_split_108.html#filepos767878"><span class="italic">jump to question</span></a></p><p class="calibre_51">At first glance, we might want to just create a second array, iterate over the elements in order, and insert them in reverse order into the new array. Unfortunately, the question says to not create a second array.</p><p class="calibre_1">Let’s look at any example.</p><blockquote class="calibre_23"><span class="calibre6"><tt class="calibre10">Original: 0, 1, 2, 3, 4, 5, 6</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">Reversed: 6, 5, 4, 3, 2, 1, 0</tt></span></blockquote><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><p class="calibre_31">You might notice that by reversing the array, we’re putting the 0 where the 6 is and the 6 where the 0 is. Likewise, the 5 and the 1 are put in each other’s places. That is, we’re swapping values!</p><p class="calibre_1">Rather than create a second array, we can iterate through the array, swapping the left values with the corresponding values on the right. We only need to iterate through the left half of the array, since the right half of the array will have been taken care of already.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">void reverse(int[] array) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   int midpoint = array.length / 2;</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">   for (int i = 0; i &lt; midpoint; i++) {</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">     /* Get corresponding index on right side.*/</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">     int otherside = array.length - 1 - i;</tt></span></li><li value="6" class="calibre_60"><br class="calibre1"/></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">     /* Swap left and right values.*/</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">     int temp = array[otherside];</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">     array[otherside] = array[i];</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">     array[i] = temp;</tt></span></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">Be very careful with the arithmetic on lines 2 and 5. Those are the sorts of things you should double and triple check in an interview.</p><p class="calibre_1">Both algorithms will take O(N) time.</p><p class="calibre_30"><span class="calibre4"><span class="bold">16.3</span></span><span class="calibre4"> Given two lists (A and B) of unique strings, write a program to determine if A is a subset of B. That is, check if all the elements from A are contained in B. </span><a id="filepos843695"></a></p><p class="calibre_64"><a href="index_split_108.html#filepos769225"><span class="italic">jump to question</span></a></p><p class="calibre_51">We’re told that the two lists contain unique strings, so we only need to check if all the elements in one list are contained in the other.</p><p class="calibre_1"><span class="calibre4"><span class="bold">Approach 1: Brute Force</span></span></p><p class="calibre_14">We can approach this by “brute force.” For each element in A, check if it is in B.</p><p class="calibre_1">As soon as we find an element a in A which is not in B, we can return false because we know A is not a subset. If we reach the end of A and haven’t returned yet, then we know we were able to find every element. We return true.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">boolean isSubsetBruteForce(String[] bigger, String[] smaller) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   for (String s : smaller) {</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">     boolean found = false;</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">     for (String b : bigger) {</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">        /* found element.*/</tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">        if (s.equals(b)) { </tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">         found = true;</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">         break;</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">        }</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">     </tt></span><br class="calibre1"/></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">     /* s wasn’t found -&gt; not subset. */</tt></span><br class="calibre1"/></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">     if (!found) { </tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">        return false;</tt></span></li><li value="15" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="16" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="17" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="18" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* all elements found. */</tt></span><br class="calibre1"/></li><li value="19" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return true; </tt></span></li><li value="20" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">This algorithm takes O(a*b) time, where a is the length of A and b is the length of B.</p><p class="calibre_1"><span class="calibre4"><span class="bold">Approach 2: Hashtable</span></span></p><p class="calibre_14">The reason that the earlier approach is so slow is that we have to search through B for each element. Wouldn’t it be nice if we could just look up if an element is in B?</p><p class="calibre_1">We can! This is what a hashtable allows us to do. We can build a hashtable of all the elements in B. Then, when we want to look up if an element is in B, we just use that hashtable.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">boolean isSubset(String[] bigger, String[] smaller) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   Hashtable&lt;String, Boolean&gt; hash = new Hashtable&lt;String, Boolean&gt;();</tt></span></li><li value="3" class="calibre_60"><br class="calibre1"/></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Record all the elements in the bigger list.*/</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">   for (String b : bigger) {</tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">     hash.put(b, true);</tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="8" class="calibre_60"><br class="calibre1"/></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Check if the bigger hashtable contains all the strings.*/</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">   for (String s : smaller) {</tt></span></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">     if (!hash.containsKey(s) || hash.get(s) != true) {</tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">        return false;</tt></span></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="15" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="16" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return true;</tt></span></li><li value="17" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">This algorithm takes O(a+b) time, where a is the length of A and b is the length of B. It takes O(b) additional memory to hold the hashtable.</p><p class="calibre_30"><span class="calibre4"><span class="bold">16.4</span></span><span class="calibre4"> You are given a two-dimensional array of sales data where the first column is a product ID and the second column is the quantity. Write a function to take this list of data and return a new two-dimensional array with the total sales for each product ID. </span><a id="filepos850066"></a></p><blockquote class="calibre_5">Example:</blockquote><blockquote class="calibre_55">Input:</blockquote><blockquote class="calibre_55"><span class="calibre6"><tt class="calibre10">211,4</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">262,3</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">211,5</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">216,6</tt></span></blockquote><blockquote class="calibre_5">Output:</blockquote><blockquote class="calibre_55"><span class="calibre6"><tt class="calibre10">211,9</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">262,3</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">216,6</tt></span></blockquote><p class="calibre_64"><a href="index_split_108.html#filepos769709"><span class="italic">jump to question</span></a></p><p class="calibre_51">The output for this method needs to be a list of product IDs and their total counts. We can do this in a straightforward manner by using a hashtable.</p><p class="calibre_1">We iterate through the list of (productID, quantity) pairs. For each value, we increment its entry in the hashtable or insert it if it’s not already in there. Finally, we convert the hashtable back into an array.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">int[][] totalSales(int[][] data) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   Hashtable&lt;Integer, Integer&gt; hash = new Hashtable&lt;Integer, Integer&gt;();</tt></span></li><li value="3" class="calibre_60"><br class="calibre1"/></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Compute total sales of each product.*/</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">   for (int i = 0; i &lt; data.length; i++) {</tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">     int productId = data[i][0];</tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">     int quantity = data[i][1];</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">     if (hash.containsKey(productId)) {</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">        quantity = quantity + hash.get(productId);</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">     hash.put(productId, quantity);</tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="13" class="calibre_60"><br class="calibre1"/></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Convert hashtable back to array.*/</tt></span></li><li value="15" class="calibre_60"><span class="calibre5"><tt class="calibre10">   int[][] totals = new int[hash.keySet().size()][2];</tt></span></li><li value="16" class="calibre_60"><span class="calibre5"><tt class="calibre10">   int index = 0;</tt></span></li><li value="17" class="calibre_60"><span class="calibre5"><tt class="calibre10">   for (int key : hash.keySet()) {</tt></span></li><li value="18" class="calibre_60"><span class="calibre5"><tt class="calibre10">     totals[index][0] = key;</tt></span></li><li value="19" class="calibre_60"><span class="calibre5"><tt class="calibre10">     totals[index][1] = hash.get(key);</tt></span></li><li value="20" class="calibre_60"><span class="calibre5"><tt class="calibre10">     index = index + 1;</tt></span></li><li value="21" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="22" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="23" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return totals;</tt></span></li><li value="24" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">If you don’t know the specific commands for things like keySet and containsKey, don’t worry. Your interviewer shouldn’t care about things like this. The important thing is that you know how to translate an approach into something that resembles workable code.</p><p class="calibre_1">This algorithm takes O(N) time, where N is the number of lines in the input.</p><p class="calibre_30"><span class="calibre4"><span class="bold">16.5</span></span><span class="calibre4"> Insert an element into a binary search tree (in order). You may assume that the binary search tree contains integers. </span><a id="filepos855083"></a></p><p class="calibre_64"><a href="index_split_108.html#filepos772918"><span class="italic">jump to question</span></a></p><p class="calibre_51">This is a straightforward question that follows from the definition of a binary search tree.</p><p class="calibre_1">In a binary search tree, lesser values are put on the left of a node and greater values are put on the right.</p><p class="calibre_1">The easiest way to implement this is recursively. Start with the root and compare the value you want to insert, x. If x is less than the root, then call insert on the root.left. When x is greater than the root, then call insert on the right side. Repeat this until you don’t have a left or right child. Insert x there.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">boolean insert(TreeNode root, int data) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   if (root == null) { // failure</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">     return false;</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="5" class="calibre_60"><br class="calibre1"/></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">   if (data &lt;= root.data) {</tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">     if (root.left == null) {</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">        /* found an open spot.*/</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">        root.left = new TreeNode(data); </tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">     } else {</tt></span></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">        /* recurse to insert node on left */</tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">        return insert(root.left, data); </tt></span></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">   } else {</tt></span></li><li value="15" class="calibre_60"><span class="calibre5"><tt class="calibre10">     if (root.right == null) { </tt></span></li><li value="16" class="calibre_60"><span class="calibre5"><tt class="calibre10">        /* found an open spot. */</tt></span></li><li value="17" class="calibre_60"><span class="calibre5"><tt class="calibre10">        root.right = new TreeNode(data); </tt></span></li><li value="18" class="calibre_60"><span class="calibre5"><tt class="calibre10">     } else {</tt></span></li><li value="19" class="calibre_60"><span class="calibre5"><tt class="calibre10">        /* recurse to insert node on right. */</tt></span></li><li value="20" class="calibre_60"><span class="calibre5"><tt class="calibre10">        return insert(root.right, data); </tt></span></li><li value="21" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="22" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="23" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="24" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return true; // success</tt></span></li><li value="25" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">The time to insert a node will depend on the height of the tree. If the tree is relatively balanced, it should have height O(log N) where N is the number of nodes in the tree. However, if the tree is very imbalanced (for example, basically a straight line down of nodes all on one side), the height could be as much as N.</p><p class="calibre_30"><span class="calibre4"><span class="bold">16.6</span></span><span class="calibre4"> Given a binary search tree which contains integers as values, calculate the sum of all the numbers. </span><a id="filepos859366"></a></p><p class="calibre_64"><a href="index_split_108.html#filepos773248"><span class="italic">jump to question</span></a></p><p class="calibre_51">If we approach problems from the right perspective, some problems are surprisingly simple. In this case, the “right” perspective means recursively.</p><p class="calibre_1">Suppose we want to compute the sum of the nodes in a tree like this:</p><p class="calibre_2"><img src="images/00012.jpg" class="calibre_57"/><br class="calibre1"/></p><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><p class="calibre_1">We could traverse the tree, collapse it into an array, and then compute the sum of those values. That’s a lot more complicated than is necessary.</p><p class="calibre_1">The simpler way is to think about the problem in terms of its subproblems. The sum of the entire tree is going to be the sum of the left subtree + sum of the right subtree + sum of the root.</p><blockquote class="calibre_23"><span class="calibre6"><tt class="calibre10">sum(tree_at_20) =</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">       sum(tree_at_10)</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">     + sum(tree_at_30)</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">     + value_at_node_20</tt></span></blockquote><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><p class="calibre_31">Getting the sum at node 10 can then be defined in terms of its subproblems.</p><blockquote class="calibre_23"><span class="calibre6"><tt class="calibre10">sum(tree_at_10) =</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">       sum(tree_at_5)</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">     + sum(tree_at_15)</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">     + value_at_node_10</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6">            </span><br class="calibre1"/></blockquote><p class="calibre_31">We can almost directly translate this into code.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">int sum(TreeNode root) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   if (root == null) {</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">     return 0;</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return root.data + sum(root.left) + sum(root.right);</tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">If we hit the end of a path (a null node), we return 0. If you prefer, we could instead do this:</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">int sum(TreeNode root) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   if (root == null) {</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">     return 0;</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="5" class="calibre_60"><br class="calibre1"/></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">   int total = root.data;</tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">   if (root.left != null) {</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">     total += sum(root.left);</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">   if (root.right != null) {</tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">     total += sum(root.right);</tt></span></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="15" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return total;</tt></span></li><li value="16" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">Regardless of which code you use, the runtime will be O(N), where N is the number of nodes in the tree.</p><p class="calibre_1">One way to see the runtime is to realize that sum will be called exactly once for each node in the tree. If there are O(N) calls to sum, then the runtime should be O(N).</p><p class="calibre_30"><span class="calibre4"><span class="bold">16.7</span></span><span class="calibre4"> Insert a node into a sorted linked list (in order). (Don’t forget about what happens when the new element is at the start or end!) </span><a id="filepos864850"></a></p><p class="calibre_64"><a href="index_split_108.html#filepos774710"><span class="italic">jump to question</span></a></p><p class="calibre_51">To insert a number in order into a linked list, we first need to find the right place to insert the node. Then, we need to actually insert it.</p><p class="calibre_1">The tricky bit is figuring out how to handle inserting a node into the front of the linked list.</p><p class="calibre_1">Imagine we call an insertInOrder method that looks like this, and it (for this particular case) needs to insert n into the front of the linked list:</p><blockquote class="calibre_23"><span class="calibre6"><tt class="calibre10">void insertInOrder(LinkedListNode nd, int value)</tt></span></blockquote><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><p class="calibre_31">Just inserting node n and having n.next point to nd is not enough. Whoever is using the linked list doesn’t know that the <span class="italic">real</span> head of the linked list has been updated from nd to n. They only have a reference to nd.</p><p class="calibre_1">Therefore, in an insert method, you need to return the new head of the linked list. Most of the time, the head will be the same as it was before you called insert. Sometimes it will change though, and you need to notify the caller of this.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">LinkedListNode insert(LinkedListNode head, int data) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Create new node.*/</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">   LinkedListNode node = new LinkedListNode(data);</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* If being insert into front of linked list, then insert node and return new head.*/</tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">   if (head == null || data &lt; head.data) {</tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">       node.next = head;</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">       return node;</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Find the right spot (in order) to insert the node by traversing through the list.*/</tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">   LinkedListNode current = head;</tt></span></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">   while (current.next != null &amp;&amp; data &gt; current.next.data) {</tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">     current = current.next;</tt></span></li><li value="15" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="16" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="17" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Insert node.*/</tt></span></li><li value="18" class="calibre_60"><span class="calibre5"><tt class="calibre10">   node.next = current.next;</tt></span></li><li value="19" class="calibre_60"><span class="calibre5"><tt class="calibre10">   current.next = node;</tt></span></li><li value="20" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="21" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Return old head. It hasn’t moved.*/</tt></span></li><li value="22" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return head;</tt></span></li><li value="23" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">This algorithm takes O(N) time, where N is the number of nodes.</p><p class="calibre_30"><span class="calibre4"><span class="bold">16.8</span></span><span class="calibre4"> “Sort” a linked list that contains just 0s and 1s. That is, modify the list such that all 0s come before all 1s. </span><a id="filepos869379"></a></p><p class="calibre_64"><a href="index_split_108.html#filepos775057"><span class="italic">jump to question</span></a></p><p class="calibre_51">There are many ways of doing this problem.</p><p class="calibre_1"><span class="calibre4"><span class="bold">Approach 1: Build Two Linked Lists</span></span></p><p class="calibre_14">One of the simplest ways is to build a “zeros list” and a “ones list” and then join them at the end.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">LinkedListNode sort(LinkedListNode head) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   LinkedListNode zeroHead = null;</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">   LinkedListNode zeroTail = null;</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">   LinkedListNode oneHead = null;</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">   LinkedListNode oneTail = null;</tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">   LinkedListNode n = head;</tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">   while (n</tt></span><tt class="calibre10"> </tt><span class="calibre5"><tt class="calibre10">!= null) {</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">     LinkedListNode next = n.next;</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">     n.next = null;</tt></span></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">     if (n.data == 0) {</tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">        /* Add to end of zeros list.*/</tt></span></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">        if (zeroHead == null) {</tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">         zeroHead = n;</tt></span></li><li value="15" class="calibre_60"><span class="calibre5"><tt class="calibre10">        } else {</tt></span></li><li value="16" class="calibre_60"><span class="calibre5"><tt class="calibre10">         zeroTail.next = n;</tt></span></li><li value="17" class="calibre_60"><span class="calibre5"><tt class="calibre10">        }</tt></span></li><li value="18" class="calibre_60"><span class="calibre5"><tt class="calibre10">        zeroTail = n;</tt></span></li><li value="19" class="calibre_60"><span class="calibre5"><tt class="calibre10">     } else {</tt></span></li><li value="20" class="calibre_60"><span class="calibre5"><tt class="calibre10">        /* Add to end of ones list.*/</tt></span></li><li value="21" class="calibre_60"><span class="calibre5"><tt class="calibre10">        if (oneHead == null) {</tt></span></li><li value="22" class="calibre_60"><span class="calibre5"><tt class="calibre10">         oneHead = n;</tt></span></li><li value="23" class="calibre_60"><span class="calibre5"><tt class="calibre10">        } else {</tt></span></li><li value="24" class="calibre_60"><span class="calibre5"><tt class="calibre10">         oneTail.next = n;</tt></span></li><li value="25" class="calibre_60"><span class="calibre5"><tt class="calibre10">        }</tt></span></li><li value="26" class="calibre_60"><span class="calibre5"><tt class="calibre10">        oneTail = n;</tt></span></li><li value="27" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="28" class="calibre_60"><span class="calibre5"><tt class="calibre10">     n = next;</tt></span></li><li value="29" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="30" class="calibre_60"><br class="calibre1"/></li><li value="31" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Join lists and return.*/</tt></span></li><li value="32" class="calibre_60"><span class="calibre5"><tt class="calibre10">   if (zeroTail == null) {</tt></span></li><li value="33" class="calibre_60"><span class="calibre5"><tt class="calibre10">     oneTail.next = null;</tt></span></li><li value="34" class="calibre_60"><span class="calibre5"><tt class="calibre10">     return oneTail;</tt></span></li><li value="35" class="calibre_60"><span class="calibre5"><tt class="calibre10">   } else {</tt></span></li><li value="36" class="calibre_60"><span class="calibre5"><tt class="calibre10">     zeroTail.next = oneHead;</tt></span></li><li value="37" class="calibre_60"><span class="calibre5"><tt class="calibre10">     return zeroHead;</tt></span></li><li value="38" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="39" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">Observe that we need to return the new head of the linked list, as it might have changed.</p><p class="calibre_1"><span class="calibre4"><span class="bold">Approach 2: Grow Left and Right</span></span></p><p class="calibre_14">The prior approach gets lengthy because we need to keep track of the front and back of two different lists, which requires constantly updating four different variables.</p><p class="calibre_1">Four variables aren’t actually necessary though. All the problem has asked us to do is to put all the 0s before the 1s. We don’t have to keep the nodes in the same order that they were in originally.</p><p class="calibre_1">Therefore, we can instead just keep track of the head and tail of the (new) linked list. When we get a new 0, we insert it at the very front. When we get a new 1, we insert it at the very end. This will keep all 0s before every 1.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">LinkedListNode sort(LinkedListNode n) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   LinkedListNode head = n;</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">   LinkedListNode tail = n;</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">   // start with second element</tt></span><br class="calibre1"/></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">   n = n.next; </tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">   while (n != null) {</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">     LinkedListNode next = n.next;</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">     if (n.data == 0) {</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">        // 0 -&gt; add to front</tt></span></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">        n.next = head;</tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">        head = n;</tt></span></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">     } else { </tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">        // 1 -&gt; add to tail</tt></span><br class="calibre1"/></li><li value="15" class="calibre_60"><span class="calibre5"><tt class="calibre10">        tail.next = n;</tt></span></li><li value="16" class="calibre_60"><span class="calibre5"><tt class="calibre10">        tail = n;</tt></span></li><li value="17" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="18" class="calibre_60"><span class="calibre5"><tt class="calibre10">     n = next;</tt></span></li><li value="19" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="20" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="21" class="calibre_60"><span class="calibre5"><tt class="calibre10">   // ensure tail doesn’t point anywhere</tt></span><br class="calibre1"/></li><li value="22" class="calibre_60"><span class="calibre5"><tt class="calibre10">   tail.next = null; </tt></span></li><li value="23" class="calibre_60"><br class="calibre1"/></li><li value="24" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return head;</tt></span></li><li value="25" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">We again need to return the new head since it might have changed.</p><p class="calibre_1"><span class="calibre4"><span class="bold">Approach 3: Count the Zeros</span></span></p><p class="calibre_14">We’re not actually required to use the same actual objects that we were given. If we moved values, instead of nodes, that would fit the problem requirements.</p><p class="calibre_1">Therefore, we can just iterate through the linked list once, counting the number of 0s. Then, we iterate through it again, setting the first k values to 0 and the rest to 1.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">void sort(LinkedListNode head) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   int k = 0;</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Count the number of 0s.*/</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">   LinkedListNode n = head;</tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">   while (n != null) {</tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">     if (n.data == 0) {</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">        k = k + 1;</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">     n = n.next;</tt></span></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="12" class="calibre_60"><br class="calibre1"/></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Set first k values to 0.*/</tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">   n = head;</tt></span></li><li value="15" class="calibre_60"><span class="calibre5"><tt class="calibre10">   while (n != null) {</tt></span></li><li value="16" class="calibre_60"><span class="calibre5"><tt class="calibre10">     if (k &gt; 0) {</tt></span></li><li value="17" class="calibre_60"><span class="calibre5"><tt class="calibre10">        n.data = 0;</tt></span></li><li value="18" class="calibre_60"><span class="calibre5"><tt class="calibre10">        k = k - 1;</tt></span></li><li value="19" class="calibre_60"><span class="calibre5"><tt class="calibre10">     } else {</tt></span></li><li value="20" class="calibre_60"><span class="calibre5"><tt class="calibre10">        n.data = 1;</tt></span></li><li value="21" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="22" class="calibre_60"><span class="calibre5"><tt class="calibre10">     n = n.next;</tt></span></li><li value="23" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="24" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">In this approach, we’re moving values, not nodes. The actual reference to the head won’t change, so we don’t need to return anything.</p><p class="calibre_1"><span class="calibre4"><span class="bold">Approach 4: Swap the Values</span></span></p><p class="calibre_14">Since we only need to move the values, we can also just iterate through the linked list, swapping the 0s and 1s as we find them.</p><p class="calibre_1">This approach works by two pointers, p and q. The p pointer looks for 1s and the q pointer looks for 0s. When they find their values, they swap.</p><div class="calibre_15"> </div><ol class="calibre_65"><li value="1" class="calibre_29">Start p at head. <blockquote class="calibre_5"><span class="calibre5"><tt class="calibre10">0-&gt;0-&gt;0-&gt;1-&gt;1-&gt;0-&gt;1-&gt;0-&gt;1-&gt;0</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre5"><tt class="calibre10">p</tt></span></blockquote></li><li value="2" class="calibre_29">Move p to first 1. <blockquote class="calibre_5"><span class="calibre5">0-&gt;0-&gt;0-&gt;1-&gt;1-&gt;0-&gt;1-&gt;0-&gt;1-&gt;0</span></blockquote><blockquote class="calibre_5"><span class="calibre5"><tt class="calibre10">         p</tt></span></blockquote></li><li value="3" class="calibre_29">Start q at p.next. <blockquote class="calibre_5"><span class="calibre5"><tt class="calibre10">0-&gt;0-&gt;0-&gt;1-&gt;1-&gt;0-&gt;1-&gt;0-&gt;1-&gt;0</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre5"><tt class="calibre10">         p  q</tt></span></blockquote></li><li value="4" class="calibre_29">Move q to next 0. <blockquote class="calibre_5"><span class="calibre5"><tt class="calibre10">0-&gt;0-&gt;0-&gt;1-&gt;1-&gt;0-&gt;1-&gt;0-&gt;1-&gt;0</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre5"><tt class="calibre10">         p     q</tt></span></blockquote></li><li value="5" class="calibre_29">Swap values at p and q. <blockquote class="calibre_5"><span class="calibre5"><tt class="calibre10">0-&gt;0-&gt;0-&gt;0-&gt;1-&gt;1-&gt;1-&gt;0-&gt;1-&gt;0</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre5"><tt class="calibre10">         p     q</tt></span></blockquote></li><li value="6" class="calibre_29">Repeat at step 4: <blockquote class="calibre_5"><span class="calibre5"><tt class="calibre10">// move p to next 1</tt></span><br class="calibre1"/></blockquote><blockquote class="calibre_5"><span class="calibre5"><tt class="calibre10">0-&gt;0-&gt;0-&gt;0-&gt;1-&gt;1-&gt;1-&gt;0-&gt;1-&gt;0</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre5"><tt class="calibre10">            p  q </tt></span></blockquote><blockquote class="calibre_5"><span class="calibre5"><tt class="calibre10">// move q to next 0</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre5"><tt class="calibre10">0-&gt;0-&gt;0-&gt;0-&gt;1-&gt;1-&gt;1-&gt;0-&gt;1-&gt;0</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre5"><tt class="calibre10">            p        q </tt></span><br class="calibre1"/></blockquote><blockquote class="calibre_5"><span class="calibre5"><tt class="calibre10">// swap</tt></span><br class="calibre1"/></blockquote><blockquote class="calibre_5"><span class="calibre5"><tt class="calibre10">0-&gt;0-&gt;0-&gt;0-&gt;0-&gt;1-&gt;1-&gt;1-&gt;1-&gt;0</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre5"><tt class="calibre10">            p        q </tt></span><br class="calibre1"/></blockquote><blockquote class="calibre_5"><span class="calibre5"><tt class="calibre10">// move p to next 1</tt></span><br class="calibre1"/></blockquote><blockquote class="calibre_5"><span class="calibre5"><tt class="calibre10">0-&gt;0-&gt;0-&gt;0-&gt;0-&gt;1-&gt;1-&gt;1-&gt;1-&gt;0</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre5"><tt class="calibre10">               p     q </tt></span><br class="calibre1"/></blockquote><blockquote class="calibre_5"><span class="calibre5"><tt class="calibre10">// move q to next 0</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre5"><tt class="calibre10">0-&gt;0-&gt;0-&gt;0-&gt;0-&gt;1-&gt;1-&gt;1-&gt;1-&gt;0</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre5"><tt class="calibre10">               p           q  </tt></span></blockquote><blockquote class="calibre_5"><span class="calibre5"><tt class="calibre10">// swap</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre5"><tt class="calibre10">0-&gt;0-&gt;0-&gt;0-&gt;0-&gt;0-&gt;1-&gt;1-&gt;1-&gt;1</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre5"><tt class="calibre10">               p           q</tt></span><br class="calibre1"/></blockquote></li></ol><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><p class="calibre_1">In other words, p is always pointing to the first 1 and q is always pointing to the first out of place 0 (which is the first 0 after p). Whenever q finds a 0, we know the 0 is out of place. We swap its value with p and move p to the next node.</p><p class="calibre_1">This approach might be the least intuitive for some people, but—with the use of a helper function—it leads to fairly short code.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">void sort(LinkedListNode head) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   // find first 1</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">   LinkedListNode p = nextNodeWithVal(head, 1); </tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">   // find next 0</tt></span><br class="calibre1"/></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">   LinkedListNode q = nextNodeWithVal(p.next, 0); </tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">   while (p != null &amp;&amp; q != null) {</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">     q.data = 1; // swap</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">     p.data = 0;</tt></span></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">     </tt></span><br class="calibre1"/></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">     // find next 1</tt></span><br class="calibre1"/></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">     p = nextNodeWithVal(p, 1); </tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">     </tt></span><br class="calibre1"/></li><li value="15" class="calibre_60"><span class="calibre5"><tt class="calibre10">     // find next 0</tt></span><br class="calibre1"/></li><li value="16" class="calibre_60"><span class="calibre5"><tt class="calibre10">     q = nextNodeWithVal(q, 0); </tt></span></li><li value="17" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="18" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li><li value="19" class="calibre_60"><br class="calibre1"/></li><li value="20" class="calibre_60"><span class="calibre5"><tt class="calibre10">LinkedListNode nextNodeWithVal(LinkedListNode n, int data) {</tt></span></li><li value="21" class="calibre_60"><span class="calibre5"><tt class="calibre10">   while (n != null &amp;&amp; n.data != data) {</tt></span></li><li value="22" class="calibre_60"><span class="calibre5"><tt class="calibre10">           n = n.next;</tt></span></li><li value="23" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="24" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return n;</tt></span></li><li value="25" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">These are just four ways of solving the problem, but there are many other ways too. These four approaches are all O(N).</p><p class="calibre_30"><span class="calibre4"><span class="bold">16.9</span></span><span class="calibre4"> Write a function which takes a stack as input and returns a new stack which has the elements reversed. </span><a id="filepos890320"></a></p><p class="calibre_64"><a href="index_split_108.html#filepos776590"><span class="italic">jump to question</span></a></p><p class="calibre_51">The most straightforward way to do this is to just create a new stack and pop the elements from the first stack onto the second. This will put the top element from the original stack on the bottom of the new stack.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">Stack&lt;Integer&gt; reverse(Stack&lt;Integer&gt; stack) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   Stack&lt;Integer&gt; reversed = new Stack&lt;Integer&gt;();</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">   while (!stack.isEmpty()) {</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">     reversed.push(stack.pop());</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return reversed;</tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">The only problem with this is that our original stack gets completely emptied in the process. If this is a problem (ask your interviewer!), then you can use an additional stack to hold all the popped values.</p><p class="calibre_1">We push the popped values onto both the temp stack and the reversed stack. (These stacks will have the same elements in the same—reversed—order.) Once we’re done popping the elements from stack, we push them back from temp onto stack.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">Stack&lt;Integer&gt; reverseWithoutDestroying(Stack&lt;Integer&gt; stack) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   Stack&lt;Integer&gt; reversed = new Stack&lt;Integer&gt;();</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">   Stack&lt;Integer&gt; temp = new Stack&lt;Integer&gt;();</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">   while (!stack.isEmpty()) {</tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">     int x = stack.pop();</tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">     reversed.push(x);</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">     temp.push(x);</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">   while (!temp.isEmpty()) {</tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">     stack.push(temp.pop());</tt></span></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return reversed;</tt></span></li><li value="15" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">Both approaches will have O(N) runtime. The second one will go through two passes instead of one, but constants don’t affect the big O time. This may seem surprising to some people, but remember: big O is not an expression of how many seconds something actually takes. It expresses how the time scales (in this case, linear) as the size of the input gets longer and longer.</p><p class="calibre_30"><span class="calibre4"><span class="bold">16.10</span></span><span class="calibre4"> Write a function which removes all the even numbers from a stack. You should return the original stack, not a new one. </span><a id="filepos894556"></a></p><p class="calibre_64"><a href="index_split_108.html#filepos776940"><span class="italic">jump to question</span></a></p><p class="calibre_51">For this problem, we can rely on the same instinct as the second approach from the prior problem: reversing something twice puts the elements back in their original order.</p><p class="calibre_1">We can just pop the stack, element by element. If the element is odd (that is, not even), push it onto a new, temporary stack. Then, once we’re all done, push them back onto their original stack.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">void removeEvens(Stack&lt;Integer&gt; stack) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   Stack&lt;Integer&gt; temp = new Stack&lt;Integer&gt;();</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">   while (!stack.isEmpty()) {</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">     int x = stack.pop();</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">     </tt></span><br class="calibre1"/></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">     /* Push evens onto new stack.*/</tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">     if (x % 2 != 0) {</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">        temp.push(x);</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Return odds to the stack.*/</tt></span></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">   while (!temp.isEmpty()) {</tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">     stack.push(temp.pop());</tt></span></li><li value="15" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="16" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">This algorithm will take O(N) time. Observe that, since you have to go through every element, you can’t solve the problem any faster than this.</p><p class="calibre_30"><span class="calibre4"><span class="bold">16.11</span></span><span class="calibre4"> Write a function to check if two queues are identical (same values in the same order). It’s okay to modify/destroy the two queues. </span><a id="filepos897423"></a></p><p class="calibre_64"><a href="index_split_108.html#filepos778254"><span class="italic">jump to question</span></a></p><p class="calibre_51">We are allowed to modify the two queues, which should give us a clue that we need to do just that.</p><p class="calibre_1">We can repeatedly remove the front of each linked list and compare the values. If the values are not equal, then we immediately return false.</p><p class="calibre_1">What happens when one list is emptied? That depends. If both lists are empty, then we know the linked lists are identical (nothing has failed yet). However, if only one list is empty and the other is not, then we know the lists were of different sizes. After all, we’re removing the elements in the same order.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">boolean isEqual(Queue&lt;Integer&gt; one, Queue&lt;Integer&gt; two) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Remove elements one by one and check that they’re equal.*/</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">   while (!one.isEmpty() &amp;&amp; !two.isEmpty()) {</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">     int oneHead = one.remove();</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">     int twoHead = two.remove();</tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">     if (oneHead != twoHead) {</tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">        return false;</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* We exited because one list was emptied. If the other list has elements left in it, then they must have been of different sizes. */</tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">   if (!one.isEmpty() || !two.isEmpty()) {</tt></span></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">     return false;</tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="15" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return true;</tt></span></li><li value="16" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">This algorithm takes O(N) time, where N is the length of the smaller list. Why the smaller? Because we exit as soon as <span class="italic">either</span> list is empty. That will happen to the smaller list first. It doesn’t matter how big the bigger list is; it won’t affect the runtime.</p><p class="calibre_30"><span class="calibre4"><span class="bold">16.12</span></span><span class="calibre4"> Write a function to remove the 13th element from a queue (but keep all the other elements in place and in the same order). </span><a id="filepos900808"></a></p><p class="calibre_64"><a href="index_split_108.html#filepos778462"><span class="italic">jump to question</span></a></p><p class="calibre_51">The approach to this problem depends on what you assume the queue data structure supports.</p><p class="calibre_1">If we get access to a Node class, then this is fairly easy. We just iterate through the nodes and delete it when we get to the 13th.</p><p class="calibre_1">However, if it’s a true Queue class, we don’t necessarily have access to the nodes like this. We may only have an add (to the back of the list) and remove (from the front of the list) method.</p><p class="calibre_1">We could create a second list object, but this isn’t actually necessary. Observe that if we continuously remove elements from the front and add them to the back, we’ll wind up with the exact same list.</p><p class="calibre_1">To remove the 13th element, we can therefore just remove each element and re-add it—skipping the 13th element.</p><p class="calibre_1">We’ve implemented this code using a variable k, rather than hard coding the number 13. This is generally a good coding practice.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">boolean remove(Queue&lt;Integer&gt; queue, int k) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   if (k &lt; 0 || k &gt;= queue.size()) {</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">     return false;</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">   int size = queue.size();</tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">   for (int i = 0; i &lt; size; i++) {</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">     int head = queue.remove();</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">     </tt></span><br class="calibre1"/></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">     /* everything but the kth element */</tt></span><br class="calibre1"/></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">     if (i != k) { </tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">        /* remove from front and add to back */</tt></span></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">        queue.add(head);</tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="15" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="16" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return true;</tt></span></li><li value="17" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">This algorithm takes O(N) time, where N is the number of nodes.</p><p class="calibre_30"><span class="calibre4"><span class="bold">16.13</span></span><span class="calibre4"> Given two sorted arrays, write a function to merge them in sorted order into a new array. </span><a id="filepos904372"></a></p><p class="calibre_64"><a href="index_split_108.html#filepos783389"><span class="italic">jump to question</span></a></p><p class="calibre_51">The most efficient way to tackle this is to use the fact that the arrays are sorted. We can merge them by taking successive elements repeatedly until we reach the end of both arrays. We maintain pointers to where we are in each array so that we can just easily move onto the next array.</p><p class="calibre_1">Let’s take an example of two arrays.</p><blockquote class="calibre_23"><span class="calibre6"><tt class="calibre10">A: 1 5 8 9     B: 2 4 9 10 12</tt></span></blockquote><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><p class="calibre_31">We’ll start off with the p and q pointers at the beginning of the two arrays:</p><blockquote class="calibre_23"><span class="calibre6"><tt class="calibre10">A: 1 5 8 9     B: 2 4 9 10 12</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">   p              q</tt></span></blockquote><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><p class="calibre_31">A[p] is smaller than A[q], so we put A[p] into our result array. We then move p to the next value.</p><blockquote class="calibre_23"><span class="calibre6"><tt class="calibre10">A: 1 5 8 9     B: 2 4 9 10 12     </tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">     p            q </tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">Result: 1</tt></span><br class="calibre1"/></blockquote><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><p class="calibre_31">We compare A[p] and A[q] again, putting the smaller element into the resulting array. We also need to keep track of where we are in the result array. We repeat this process until we are done with both arrays.</p><blockquote class="calibre_23"><span class="calibre6"><tt class="calibre10">A: 1 5 8 9     B: 2 4 9 10 12     </tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">     p              q</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">Result: 1 2</tt></span><br class="calibre1"/></blockquote><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">A: 1 5 8 9     B: 2 4 9 10 12     </tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">     p                q</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">Result: 1 2 4</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">      </tt></span><br class="calibre1"/></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">A: 1 5 8 9     B: 2 4 9 10 12     </tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">       p              q</tt></span><br class="calibre1"/></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">Result: 1 2 4 5</tt></span><br class="calibre1"/></blockquote><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">A: 1 5 8 9     B: 2 4 9 10 12     </tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">         p            q</tt></span><br class="calibre1"/></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">Result: 1 2 4 5 8</tt></span><br class="calibre1"/></blockquote><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">A: 1 5 8 9     B: 2 4 9 10 12     </tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">                      q</tt></span><br class="calibre1"/></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">Result: 1 2 4 5 8 9</tt></span><br class="calibre1"/></blockquote><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">A: 1 5 8 9     B: 2 4 9 10 12     </tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">                         q</tt></span><br class="calibre1"/></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">Result: 1 2 4 5 8 9 9</tt></span><br class="calibre1"/></blockquote><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">A: 1 5 8 9     B: 2 4 9 10 12     </tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">                            q</tt></span><br class="calibre1"/></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">Result: 1 2 4 5 8 9 9 10</tt></span><br class="calibre1"/></blockquote><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">A: 1 5 8 9     B: 2 4 9 10 12     </tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">                            </tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">Result: 1 2 4 5 8 9 9 10 12</tt></span><br class="calibre1"/></blockquote><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><p class="calibre_31">In an interview, it’s useful to walk through the example in this detail to reduce the number of mistakes you make.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">int[] mergeIntoNew(int[] A, int[] B) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   int p = 0;</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">   int q = 0;</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">   int index = 0;</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">   int sz = A.length + B.length;</tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">   int[] merged = new int[sz];</tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">   while (p &lt; A.length || q &lt; B.length) {</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">     if (q &gt;= B.length || A[p] &lt;= B[q]) {</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">        merged[index] = A[p];</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">        p = p + 1;</tt></span></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">     } else {</tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">        merged[index] = B[q];</tt></span></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">        q = q + 1;</tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="15" class="calibre_60"><span class="calibre5"><tt class="calibre10">     index = index + 1;</tt></span></li><li value="16" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="17" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return merged;</tt></span></li><li value="18" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">If you wanted to reduce the number of pointers we have, we can remove the index variable. It will always be equal to p + q.</p><p class="calibre_1">This code takes O(M+N) time, where M is the length of the first array and N is the length of the second.</p><p class="calibre_30"><span class="calibre4"><span class="bold">16.14</span></span><span class="calibre4"> Implement insertion sort. </span><a id="filepos912293"></a></p><p class="calibre_64"><a href="index_split_108.html#filepos783597"><span class="italic">jump to question</span></a></p><p class="calibre_51">Insertion sort operates by iterating through the array, inserting each element in order on the element’s left side.</p><p class="calibre_1">We can most cleanly implement this as two different functions.</p><p class="calibre_1">The first function performs the overall algorithm: pick up an element, insert it in order, pick up the next one, and so on.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">void insertionSort(int[] array) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Pick up elements starting from the left and insert them into the left in order */</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">   for (int i = 1; i &lt; array.length; i++) {</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">     insertInOrder(array, i);</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">Observe that our for loop starts at 1 instead of 0. This is because the 0th element can never be out of order, by itself. (A single element subarray is always sorted.)</p><p class="calibre_1">Now we just need to implement a method that will take an element A[k] and insert it in order into the elements to the left of it (provided those are sorted).</p><p class="calibre_1">To insert A[k] in order, we will need to shift each element over by one, until we find the right spot for the element.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">void insertInOrder(int[] array, int index) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   // store element into temporary value</tt></span><br class="calibre1"/></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">   int x = array[index]; </tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">   index = index - 1;</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">   while (index &gt;= 0 &amp;&amp; array[index] &gt; x) {</tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">     // shift over by one</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">     array[index + 1] = array[index];</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">     index = index - 1;</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">   // insert element</tt></span><br class="calibre1"/></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">   array[index + 1] = x; </tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">This algorithm will take O(N<sup class="calibre11"><small class="calibre12">2</small></sup>) time.</p><p class="calibre_30"><span class="calibre4"><span class="bold">16.15</span></span><span class="calibre4"> Implement binary search. That is, given a sorted array of integers and a value, find the location of that value. </span><a id="filepos916216"></a></p><p class="calibre_64"><a href="index_split_108.html#filepos785496"><span class="italic">jump to question</span></a></p><p class="calibre_51">Binary search works by repeatedly “halving” the array into subarrays. In the first iteration, we compare the value x to the midpoint and learn whether x will be in the left half or the right half. Then, we repeat this step with this new subarray: is x found on the left half of it (the new subarray) or the right?</p><p class="calibre_1">We can implement this either recursively or iteratively (non-recursively). We’ll start with the recursive solution since it’s more intuitive for most people.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">int search(int[] array, int x) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return search(array, x, 0, array.length - 1);</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li><li value="4" class="calibre_60"><br class="calibre1"/></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">int search(int[] array, int x, int left, int right) {</tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">   // Not found</tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">   if (right &lt; left) { </tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">     return -1;</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">   int middle = (right + left) / 2;</tt></span></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">   if (x == array[middle]) {</tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">     return middle;</tt></span></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">   } else if (x &lt; array[middle]) { </tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">     // x is on left hand&gt;</tt></span></li><li value="15" class="calibre_60"><span class="calibre5"><tt class="calibre10">     return search(array, x, left, middle - 1);</tt></span></li><li value="16" class="calibre_60"><span class="calibre5"><tt class="calibre10">   } else { // x is on right hand</tt></span></li><li value="17" class="calibre_60"><span class="calibre5"><tt class="calibre10">     return search(array, x, middle + 1, right);</tt></span></li><li value="18" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="19" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">For the iterative solution, we take a very similar approach.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">int search(int[] array, int x) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   int left = 0;</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">   int right = array.length - 1;</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">   while (left &lt;= right) {</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">     int middle = (right + left) / 2;</tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">     if (x == array[middle]) {</tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">        return middle;</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">     if (x &lt; array[middle]) {</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">        right = middle - 1;</tt></span></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">     } else {</tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">        left = middle + 1;</tt></span></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="15" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return -1;</tt></span></li><li value="16" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">A good exercise is to think about how different bits of logic from the recursive solution translates to the iterative solution. For example, what happened to the check on line 6 of the recursive solution?</p><p class="calibre_30"><span class="calibre4"><span class="bold">16.16</span></span><span class="calibre4"> You are given an integer array which was sorted, but then rotated. It contains all distinct elements. Find the minimum value. For example, the array might be 6, 8, 9, 11, 15, 20, 3, 4, 5. The minimum value would obviously be 3. </span><a id="filepos921659"></a></p><p class="calibre_64"><a href="index_split_108.html#filepos785764"><span class="italic">jump to question</span></a></p><p class="calibre_51">A brute force solution would be to just iterate through the array and look for the minimum value. We can guess that this isn’t what the interviewer is looking for though, since it doesn’t use the sorting information.</p><p class="calibre_1">To come up with a more optimal solution, we probably want to use the information we’re given—the array is “sorted,” but rotated.</p><p class="calibre_1">Since the array is somewhat sorted, let’s think about applying some of the concepts from binary search. Binary search works by looking at the midpoint repeatedly.</p><p class="calibre_1">In this problem, what does the midpoint tell us? In and of itself, the midpoint being 15 doesn’t tell us anything. However, if we know that the left side is 6 and the right side is 5, we can conclude something. Since left &gt; right, we know that the array is out of order. But since left &lt; middle, we know the left is in order but the right is not.</p><blockquote class="calibre_23"><span class="calibre6"><tt class="calibre10">6, _, _, _, 15, _, _, _, 5</tt></span></blockquote><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><p class="calibre_31">From examining the above array, we can determine that the inflection point (which is the minimum element) is on the right half. Our problem is now divided in half.</p><p class="calibre_1">To find the minimum element, we now just recurse.</p><blockquote class="calibre_23"><span class="calibre6"><tt class="calibre10">20, _, _, 5</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">20, 3</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">3</tt></span></blockquote><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><p class="calibre_31">We can implement this recursively. We stop when we find that the left side is less than the right side. This indicates that this portion of the array is in order, and therefore that the left is the smallest element.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">int findMin(int[] array, int left, int right) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Items are in order. Therefore, left must be minimum.*/</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">   if (array[left] &lt;= array[right]) {</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">     return left;</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Find half with minimum element.*/</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">   int middle = (right + left) / 2;</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">   if (array[left] &gt; array[middle]) {</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">     return findMin(array, left, middle);</tt></span></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">   } else { // middle element &gt; right element</tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">     return findMin(array, middle + 1, right);</tt></span></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">Alternatively, we can implement this algorithm iteratively with a while loop.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">int findMin(int[] array) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   int left = 0;</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">   int right = array.length - 1;</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">   while (array[left] &gt; array[right]) {</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">     int middle = (left + right) / 2;</tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">     if (array[left] &gt; array[middle]) {</tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">        right = middle;</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">     } else {</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">        left = middle + 1;</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return left;</tt></span></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">Be very careful in problems like this with your termination and recursion conditions. Think about things like why you make left = middle + 1 (why the +1?) but right = middle. Those are easy places to make mistakes.</p><p class="calibre_30"><span class="calibre4"><span class="bold">16.17</span></span><span class="calibre4"> Using depth-first search, check if a tree contains a value. </span><a id="filepos927668"></a></p><p class="calibre_64"><a href="index_split_108.html#filepos788107"><span class="italic">jump to question</span></a></p><p class="calibre_51">Depth-first search works by checking if a value v is equal to the current node’s value. If it is not, then you search each child of the node, one by one.</p><p class="calibre_1">The difference between depth-first search (DFS) and breadth-first search (BFS) is that in DFS, the entire subtree of a node’s child is searched before you move on to any of the node’s other children. That is, all of node.child[0].children will be searched before you even look at node.child[1].</p><p class="calibre_1">We can implement this recursively.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">boolean depthFirstSearch(TreeNode node, int x) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   if (node == null) {</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">     return false;</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">   } else if (node.data == x) {</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">     return true;</tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">   } else {</tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">     return depthFirstSearch(node.left, x) || depthFirstSearch(node.right, x);</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">Because this is a tree, we don’t need to be concerned about infinite loops. That is, we don’t need to be concerned about traversing through node’s children, and node’s “grandchildren,” and accidentally winding up back at node—to be forever stuck in an infinite loop (yikes!). Trees specifically forbid cycles like this.</p><p class="calibre_1">If this weren’t the case—if we were in a graph instead of a tree—we would have to use an isVisited flag to indicate that we’ve already visited this node.</p><p class="calibre_30"><span class="calibre4"><span class="bold">16.18</span></span><span class="calibre4"> Write the pseudocode for breadth-first search on a binary tree. Try to be as detailed as possible. </span><a id="filepos930273"></a></p><p class="calibre_64"><a href="index_split_108.html#filepos788520"><span class="italic">jump to question</span></a></p><p class="calibre_51">To perform breadth-first search, we want to search a node level by level. That is, we want to search each of node’s children before we search any of <span class="italic">their</span> children.</p><p class="calibre_1">Although breadth-first search is conceptually straightforward (just search a node’s children, level by level), implementing it can be a little less intuitive. The main trick to remember is that we need to use a queue.</p><p class="calibre_1">A queue, as you might recall, is a data structure that allows us to add items on one side and remove them from the other side. It is a “first in, first out” (FIFO) data structure. This enables us to basically flag nodes “as to be processed later.”</p><p class="calibre_1">In BFS, we “visit” a node by comparing the value we’re searching for (x) to the current value. If it matches, we’re done and can immediately return true. Else, then we add node’s children to the end of the queue. We then move on, pulling a node from the other side and searching it.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">boolean searchBFS(TreeNode root, int x) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return searchBFS(root, x, queue);</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li><li value="5" class="calibre_60"><br class="calibre1"/></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">boolean searchBFS(TreeNode root, int x, Queue&lt;TreeNode&gt; queue) {</tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">   queue.add(root);</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">   while (!queue.isEmpty()) {</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">     TreeNode node = queue.remove();</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">     if (node.data == x) {</tt></span></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">        return true;</tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">     if (node.left != null) {</tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">        queue.add(node.left);</tt></span></li><li value="15" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="16" class="calibre_60"><span class="calibre5"><tt class="calibre10">     if (node.right != null) {</tt></span></li><li value="17" class="calibre_60"><span class="calibre5"><tt class="calibre10">        queue.add(node.right);</tt></span></li><li value="18" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="19" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="20" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return false;</tt></span></li><li value="21" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">Because this is a tree, we do not need to worry about winding up in a cycle. However, if this were not the case, we would need to use an isVisited flag to ensure we don’t revisit the same node.</p><p class="calibre_1">Breadth-first search takes O(N) time, where N is the number of nodes in the graph (or tree). This is because we might potentially need to search all of the nodes.</p><p class="calibre_30"><span class="calibre4"><span class="bold">16.19</span></span><span class="calibre4"> Design an algorithm and write code to find all solutions to the equation a<sup class="calibre16"><small class="calibre12"><span class="calibre18">3</span></small></sup> + b<sup class="calibre16"><small class="calibre12"><span class="calibre18">3</span></small></sup> = c<sup class="calibre16"><small class="calibre12"><span class="calibre18">3</span></small></sup> + d<sup class="calibre16"><small class="calibre12"><span class="calibre18">3</span></small></sup> where a, b, c, and d are positive integers less than 1000. If you wish, you can print only “interesting” solutions. That is, you can ignore solutions of the form x<sup class="calibre16"><small class="calibre12"><span class="calibre18">3</span></small></sup> + y<sup class="calibre16"><small class="calibre12"><span class="calibre18">3</span></small></sup> = x<sup class="calibre16"><small class="calibre12"><span class="calibre18">3</span></small></sup> + y<sup class="calibre16"><small class="calibre12"><span class="calibre18">3</span></small></sup> and solutions that are simple permutations of other solutions (swapping left and right hand sides, swapping a and b, swapping c and d). For example, if you were printing all solutions less than 20, you could choose to print only 2<sup class="calibre16"><small class="calibre12"><span class="calibre18">3</span></small></sup> + 16<sup class="calibre16"><small class="calibre12"><span class="calibre18">3</span></small></sup> = 9<sup class="calibre16"><small class="calibre12"><span class="calibre18">3</span></small></sup> + 15<sup class="calibre16"><small class="calibre12"><span class="calibre18">3</span></small></sup> and 1<sup class="calibre16"><small class="calibre12"><span class="calibre18">3</span></small></sup> + 12<sup class="calibre16"><small class="calibre12"><span class="calibre18">3</span></small></sup> = 9<sup class="calibre16"><small class="calibre12"><span class="calibre18">3</span></small></sup> + 10<sup class="calibre16"><small class="calibre12"><span class="calibre18">3</span></small></sup>. </span><a id="filepos935841"></a></p><p class="calibre_64"><a href="index_split_112.html#filepos826494"><span class="italic">jump to question</span></a></p><p class="calibre_51">We can start off with a naive solution. We just iterate through all possible values for a, b, c, and d. When they are equal, we can print this set.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">void cubes(int max) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   for (int a = 0; a &lt; max; a++) {</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">     int acubed = a * a * a;</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">     for (int b = 0; b &lt; max; b++) {</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">        int bcubed = b * b * b;</tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">        for (int c = 0; c &lt; max; c++) {</tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">           int ccubed = c * c * c;</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">           for (int d = 0; d &lt; max; d++) {</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">              int dcubed = d * d * d;</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">              if (acubed + bcubed == ccubed + dcubed) {</tt></span></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">                 String solution = a + “,” + b + “,” + c + “,” + d;</tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">                 System.out.println(solution);</tt></span></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">              }</tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">           }</tt></span></li><li value="15" class="calibre_60"><span class="calibre5"><tt class="calibre10">        }</tt></span></li><li value="16" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="17" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="18" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">This is a good start. Now, how can we make it faster?</p><p class="calibre_1">We can get some minor wins by “short circuiting”—i.e., breaking when the right side is already too large. We can break from the c loop when a<sup class="calibre11"><small class="calibre12"><span class="calibre14">3</span></small></sup> + b<sup class="calibre11"><small class="calibre12"><span class="calibre14">3</span></small></sup> &lt; c<sup class="calibre11"><small class="calibre12"><span class="calibre14">3</span></small></sup>. (Surprisingly, doing an equivalent check on the d loop doesn’t save us any time. Yes, we’d be breaking early from the innermost loop when d is very large. But, for all smaller values of d, we’re running an extra several steps.)</p><p class="calibre_1">We can also save a bit of time by removing duplicates. Consider the solutions below, all of which are essentially equivalent:</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">3<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> + 60<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> = 22<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> + 59<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup></tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">60<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> + 3<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> = 22<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> + 59<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup></tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">3<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> + 60<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> = 59<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> + 22<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup></tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">60<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> + 3<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> = 22<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> + 59<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup></tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">22<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> + 59<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> = 3<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> + 60<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup></tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">22<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> + 59<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> = 60<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> + 3<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup></tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">59<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> + 22<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> = 3<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> + 60<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup></tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">22<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> + 59<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> = 60<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> + 3<sup class="calibre19"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup></tt></span></li></ol><p class="calibre_31">Only one of these needs to be printed.</p><p class="calibre_1">We can cut out some of these duplicates by forcing a &lt;= b and c &lt;= d. This will prevent us from printing pairs which are equivalent other than a and b being swapped or c and d being swapped.</p><p class="calibre_1">We still need to worry about the left and right side being swapped though. If we require a &lt; c (this will be true for exactly one of the two sets), then we will remove this case too.</p><p class="calibre_1">We can handle all of these by picking the appropriate start conditions of the for loops. If we start b at a, then b will always be greater than or equal to a. We can do the same thing for c, but starting it a + 1. (Why +1? Because if c = a, then d = b. The result a<sup class="calibre11"><small class="calibre12">3</small></sup> + b<sup class="calibre11"><small class="calibre12">3</small></sup> = a<sup class="calibre11"><small class="calibre12">3</small></sup> + b<sup class="calibre11"><small class="calibre12">3</small></sup> isn’t very interesting.)</p><p class="calibre_1">We can also conclude that c is not bigger than b. This is because a &lt; b and c &lt; d. If you consider the equation a<sup class="calibre11"><small class="calibre12">3</small></sup> + b<sup class="calibre11"><small class="calibre12">3</small></sup> = c<sup class="calibre11"><small class="calibre12">3</small></sup> + d<sup class="calibre11"><small class="calibre12">3</small></sup>. It would be impossible for both of the left values to be less than both of the right values and still have the left and right sides be equal.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">void cubesBetter(int max) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   for (int a = 0; a &lt; max; a++) {</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">     int acubed = a * a * a;</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">     for (int b = a; b &lt; max; b++) {</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">        int bcubed = b * b * b;</tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">        for (int c = a + 1; c &lt; b; c++) {</tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">           int ccubed = c * c * c;</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">           if (acubed + bcubed &lt; ccubed) break;</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">           for (int d = c; d &lt; max; d++) {</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">              int dcubed = d * d * d;</tt></span></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">              if (acubed + bcubed == ccubed + dcubed) {</tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">                 String sol = a + “,” + b + “,” + c + “,” + d;</tt></span></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">                 System.out.println(sol);</tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">              }</tt></span></li><li value="15" class="calibre_60"><span class="calibre5"><tt class="calibre10">           }</tt></span></li><li value="16" class="calibre_60"><span class="calibre5"><tt class="calibre10">        }</tt></span></li><li value="17" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="18" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="19" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">This helps, but the runtime will still be O(N<sup class="calibre11"><small class="calibre12">4</small></sup>). We can do better.</p><p class="calibre_1">Let’s look at the equation we’re given: <span class="calibre5">a<sup class="calibre19"><small class="calibre12"><span class="calibre14">3</span></small></sup></span> <span class="calibre5">+ b<sup class="calibre19"><small class="calibre12"><span class="calibre14">3</span></small></sup></span> <span class="calibre5">= c<sup class="calibre19"><small class="calibre12"><span class="calibre14">3</span></small></sup></span> <span class="calibre5">+ d<sup class="calibre19"><small class="calibre12"><span class="calibre14">3</span></small></sup></span>. Once we’ve determined the values of a, b, and c, there’s only one possible value for d. The only question is if that’s an integer or not. So, rather than iterating through all possibilities for d, we can just check if the resulting d value is an integer.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">void cubes(int max) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   for (int a = 0; a &lt; max; a++) {</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">     int acubed = a * a * a;</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">     for (int b = a; b &lt; max; b++) {</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">        int bcubed = b * b * b;</tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">        for (int c = a + 1; c &lt; b; c++) {</tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">           int ccubed = c * c * c;</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">           if (acubed + bcubed &lt; ccubed) break;</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">           /* Compute cubed root of (a^3 + b^3 + c^3) and check if it’s an integer.*/</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">           int d = (int) Math.round(Math.pow((acubed + bcubed - ccubed), 1.0 / 3.0));</tt></span></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">           if (d &gt;= c &amp;&amp; acubed + bcubed == ccubed + d * d * d) {</tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">              String solution = a + “,” + b + “,” + c + “,” + d;</tt></span></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">              System.out.println(solution);</tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">           }</tt></span></li><li value="15" class="calibre_60"><span class="calibre5"><tt class="calibre10">        }</tt></span></li><li value="16" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="17" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="18" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">This is O(N<sup class="calibre11"><small class="calibre12">3</small></sup>). This is better, but not yet optimal.</p><p class="calibre_1">Let’s think about what our algorithm does. The current approach is something like this:</p><blockquote class="calibre_23"><span class="calibre6"><tt class="calibre10">for each pair (a, b) where a &lt; 1000 and b &lt; 1000:</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">   compute cubeAB = a^3 + b^3</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">   find pairs (c, d) that sum to cubeAB</tt></span></blockquote><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><p class="calibre_31">For any given pair, we are iterating across all possible <span class="italic">other</span> pairs to see if they’re equal.</p><p class="calibre_1">Instead, we can just group these pairs by sum. This requires just iterating through the pairs one time.</p><p class="calibre_1">As we iterate through the pairs, we create a mapping from sum -&gt; pair (p, q). Then, we print out all pairs of pairs within each sum. That is, if we find pair<sub class="calibre15"><small class="calibre12">1</small></sub>, pair<sub class="calibre15"><small class="calibre12">2</small></sub>, pair<sub class="calibre15"><small class="calibre12">3</small></sub>, pair<sub class="calibre15"><small class="calibre12">4</small></sub>—each with a sum of x—we would print (pair<sub class="calibre15"><small class="calibre12">1</small></sub>, pair<sub class="calibre15"><small class="calibre12">2</small></sub>), (pair<sub class="calibre15"><small class="calibre12">1</small></sub>, pair<sub class="calibre15"><small class="calibre12">3</small></sub>), (pair<sub class="calibre15"><small class="calibre12">1</small></sub>, pair<sub class="calibre15"><small class="calibre12">4</small></sub>), (pair<sub class="calibre15"><small class="calibre12">2</small></sub>, pair<sub class="calibre15"><small class="calibre12">3</small></sub>), (pair<sub class="calibre15"><small class="calibre12">2</small></sub>, pair<sub class="calibre15"><small class="calibre12">4</small></sub>), and (pair<sub class="calibre15"><small class="calibre12">3</small></sub>, pair<sub class="calibre15"><small class="calibre12">4</small></sub>).</p><p class="calibre_1">Our sum -&gt; pairs mapping might look something like this:</p><blockquote class="calibre_23"><span class="calibre6"><tt class="calibre10">260245440 = 82<sup class="calibre13"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> + 638<sup class="calibre13"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup></tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">                 = 144<sup class="calibre13"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> + 636<sup class="calibre13"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup></tt></span></blockquote><blockquote class="calibre_5"><sup class="calibre11"><small class="calibre12"><span class="calibre14"><tt class="calibre10">                                  </tt></span><br class="calibre1"/></small></sup></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">958595904 = 22<sup class="calibre13"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> + 986<sup class="calibre13"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup></tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">                 = 180<sup class="calibre13"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> + 984<sup class="calibre13"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup></tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">                 = 692<sup class="calibre13"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> + 856<sup class="calibre13"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup></tt></span></blockquote><blockquote class="calibre_5"><sup class="calibre11"><small class="calibre12"><span class="calibre14"><tt class="calibre10">                                  </tt></span><br class="calibre1"/></small></sup></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">8587000 = 46<sup class="calibre13"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> + 204<sup class="calibre13"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup></tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">              = 120<sup class="calibre13"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> + 190<sup class="calibre13"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup></tt></span></blockquote><blockquote class="calibre_5"><sup class="calibre11"><small class="calibre12"><span class="calibre14">                          </span><br class="calibre1"/></small></sup></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">95880024 = 102<sup class="calibre13"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> + 456<sup class="calibre13"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup></tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">        = 228<sup class="calibre13"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup> + 438<sup class="calibre13"><small class="calibre12"><span class="calibre14"><tt class="calibre10">3</tt></span></small></sup></tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">...</tt></span></blockquote><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><p class="calibre_31">We can implement this with a hashtable, representing the pair (a, b) with a string for simplicity.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">void cubes(int max) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Compute pairs for each sum.*/</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">   Hashtable&lt;Integer, ArrayList&lt;String&gt;&gt; map = computeSums(max);</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Print pairs of pairs.*/</tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">   printSolutions(map);</tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li><li value="8" class="calibre_60"><br class="calibre1"/></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">/* Create map from each possible to sum to all pairs that give this sum.*/</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">Hashtable&lt;Integer, ArrayList&lt;String&gt;&gt; computeSums(int max) {</tt></span></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">   Hashtable&lt;Integer, ArrayList&lt;String&gt;&gt; sums = new Hashtable&lt;Integer, ArrayList&lt;String&gt;&gt;();</tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">   for (int a = 0; a &lt; max; a++) {</tt></span></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">     for (int b = a; b &lt; max; b++) {</tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">        int sum = a * a * a + b * b * b;</tt></span></li><li value="15" class="calibre_60"><span class="calibre5"><tt class="calibre10">        String solution = a + “,” + b;</tt></span></li><li value="16" class="calibre_60"><span class="calibre5"><tt class="calibre10">        </tt></span><br class="calibre1"/></li><li value="17" class="calibre_60"><span class="calibre5"><tt class="calibre10">        /* Add sum -&gt; pair to hashtable.*/</tt></span></li><li value="18" class="calibre_60"><span class="calibre5"><tt class="calibre10">        if (!sums.containsKey(sum)) {</tt></span></li><li value="19" class="calibre_60"><span class="calibre5"><tt class="calibre10">           sums.put(sum, new ArrayList&lt;String&gt;());</tt></span></li><li value="20" class="calibre_60"><span class="calibre5"><tt class="calibre10">        }</tt></span></li><li value="21" class="calibre_60"><span class="calibre5"><tt class="calibre10">        ArrayList&lt;String&gt; solutions = sums.get(sum);</tt></span></li><li value="22" class="calibre_60"><span class="calibre5"><tt class="calibre10">        solutions.add(solution);</tt></span></li><li value="23" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="24" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="25" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return sums;</tt></span></li><li value="26" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li><li value="27" class="calibre_60"><br class="calibre1"/></li><li value="28" class="calibre_60"><span class="calibre5"><tt class="calibre10">/* Print all pairs that sum to every value.*/</tt></span></li><li value="29" class="calibre_60"><span class="calibre5"><tt class="calibre10">void printSolutions(Hashtable&lt;Integer, ArrayList&lt;String&gt;&gt; map) {</tt></span></li><li value="30" class="calibre_60"><span class="calibre5"><tt class="calibre10">   for (int sum : map.keySet()) {</tt></span></li><li value="31" class="calibre_60"><span class="calibre5"><tt class="calibre10">     ArrayList&lt;String&gt; solves = map.get(sum);</tt></span></li><li value="32" class="calibre_60"><span class="calibre5"><tt class="calibre10">     printSolutionsForSum(solves);</tt></span></li><li value="33" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="34" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li><li value="35" class="calibre_60"><br class="calibre1"/></li><li value="36" class="calibre_60"><span class="calibre5"><tt class="calibre10">void printSolutionsForSum(ArrayList&lt;String&gt; solutions) {</tt></span></li><li value="37" class="calibre_60"><span class="calibre5"><tt class="calibre10">   for (int i = 0; i &lt; solutions.size(); i++) {</tt></span></li><li value="38" class="calibre_60"><span class="calibre5"><tt class="calibre10">     for (int j = i + 1; j &lt; solutions.size(); j++) {</tt></span></li><li value="39" class="calibre_60"><span class="calibre5"><tt class="calibre10">        String sol = solutions.get(i) + “,” + solutions.get(j);</tt></span></li><li value="40" class="calibre_60"><span class="calibre5"><tt class="calibre10">        System.out.println(sol);</tt></span></li><li value="41" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="42" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="43" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">This solution takes O(N<sup class="calibre11"><small class="calibre12">2</small></sup>) time where N is max size of a, b, c, and d.</p><p class="calibre_30"><span class="calibre4"><span class="bold">16.20</span></span><span class="calibre4"> Given a string, print all permutations of that string. You can assume the word does not have any duplicate characters. </span><a id="filepos959925"></a></p><p class="calibre_64"><a href="index_split_112.html#filepos826844"><span class="italic">jump to question</span></a></p><p class="calibre_51">This is a classic recursion problem.</p><p class="calibre_1">Let’s approach this with an example that we build from the bottom up.</p><blockquote class="calibre_23"><span class="calibre6"><tt class="calibre10">a -&gt; a</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">ab -&gt; ab, ba</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">abc -&gt; abc, acb, bac, bca, cab, cba</tt></span></blockquote><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><p class="calibre_31">How could we build all permutations of abcd off of any or all of these answers?</p><p class="calibre_1">The main difference is the presence of d. If we have all permutations of abc, we could “splice” d into each of those strings (in all possible ways).</p><blockquote class="calibre_23"><span class="calibre6"><tt class="calibre10">abc -&gt; abc, acb, bac, bca, cab, cba</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">            splice(abc, d) -&gt; dabc adbc abdc abcd</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">            splice(acb, d) -&gt; dacb adcb acdb acbd</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">            splice(bac, d) -&gt; dbac bdac badc bacd</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">            splice(bca, d) -&gt; dbca bdca bcda bcad</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">            splice(cab, d) -&gt; dcab cdab cadb cabd</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">            splice(cba, d) -&gt; dcba cdba cbda cbad</tt></span></blockquote><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><p class="calibre_31">The code below implements this.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">ArrayList&lt;String&gt; permutations(String word) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Base case: word is empty.*/</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">   if (word.length() == 0) {</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">     ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">     list.add(word);</tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">     return list;</tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Remove last char and get permutations of remainder.*/</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">   String lastChar = word.substring(word.length() - 1);</tt></span></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">   String remainder = word.substring(0, word.length() - 1);</tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">   ArrayList&lt;String&gt; list = permutations(remainder);</tt></span></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">   ArrayList&lt;String&gt; result = new ArrayList&lt;String&gt;();</tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="15" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Go through all permutations of the substring, splicing lastChar into it.*/</tt></span></li><li value="16" class="calibre_60"><span class="calibre5"><tt class="calibre10">   for (String part : list) {</tt></span></li><li value="17" class="calibre_60"><span class="calibre5"><tt class="calibre10">     /* Splice lastChar into all possible positions.*/</tt></span></li><li value="18" class="calibre_60"><span class="calibre5"><tt class="calibre10">     for (int i = 0; i &lt; part.length(); i++) {</tt></span></li><li value="19" class="calibre_60"><span class="calibre5"><tt class="calibre10">        String left = part.substring(0, i);</tt></span></li><li value="20" class="calibre_60"><span class="calibre5"><tt class="calibre10">        String right = part.substring(i);</tt></span></li><li value="21" class="calibre_60"><span class="calibre5"><tt class="calibre10">        String spliced = left + lastChar + right;</tt></span></li><li value="22" class="calibre_60"><span class="calibre5"><tt class="calibre10">        result.add(spliced);</tt></span></li><li value="23" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="24" class="calibre_60"><span class="calibre5"><tt class="calibre10">     </tt></span><br class="calibre1"/></li><li value="25" class="calibre_60"><span class="calibre5"><tt class="calibre10">     /* Also splice into end. */</tt></span></li><li value="26" class="calibre_60"><span class="calibre5"><tt class="calibre10">     result.add(partial + lastChar);</tt></span></li><li value="27" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="28" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="29" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return result;</tt></span></li><li value="30" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">This algorithm will take O(N!) time (where N is the number of characters in the string) since there are N! permutations.</p><p class="calibre_1">We can’t optimize this algorithm, but there is another approach. This is less intuitive for many people.</p><p class="calibre_1">If we have the string abcd, we can build it from subresults as follows:</p><blockquote class="calibre_23"><span class="calibre6"><tt class="calibre10">perms(abcd) = {a + perms(bcd)}</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">           + {b + perms(acd)}</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">           + {c + perms(abd)}</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">           + {d + perms(abc)}</tt></span></blockquote><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><p class="calibre_31">That is, we remove each character and permute the remaining. Then, we prepend the removed character to each permutation.</p><p class="calibre_1">Rather than prepending each character to its “subpermutations,” we can let the subpermutation handle this. The permutations function gets a prefix string, which represents what currently needs to be prepended, and permutes the rest.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">void permutations(String word, String prefix) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Our prefix is fully built. Print it.*/</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">   if (word.length() == 0) {</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">     System.out.println(prefix);</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Remove each character. Permute the remainder, passing along the prefix.*/</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">   for (int i = 0; i &lt; word.length(); i++) {</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">     char c = word.charAt(i);</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">     String left = word.substring(0, i);</tt></span></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">     String right = word.substring(i + 1);</tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">     permutations(left + right, c + prefix);</tt></span></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">Like the earlier approach, this is O(N!).</p><p class="calibre_30"><span class="calibre4"><span class="bold">16.21</span></span><span class="calibre4"> In a group of people, a person is called a “celebrity” if everyone knows them but they know no one else. You are given a function </span><a id="filepos969507"></a><span class="calibre4"><span class="italic">knows(a, b)</span></span><span class="calibre4"> which tells you if person </span><span class="calibre4"><span class="italic">a</span></span><span class="calibre4"> knows person </span><span class="calibre4"><span class="italic">b</span></span><span class="calibre4">. Design an algorithm to find the celebrity (if one exists).</span><br class="calibre1"/><span class="calibre4">
</span><br class="calibre1"/><span class="calibre4"> For simplicity, you can assume that everyone is given a label from 0 to N-1. You need to implement a function </span><span class="calibre4"><span class="italic">int findCelebrity(int N)</span></span><span class="calibre4">.</span><br class="calibre1"/><span class="calibre4">
</span><br class="calibre1"/><span class="calibre4"> Observe that: </span></p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_39"><span class="calibre4">There can only be one celebrity at most (due to the definition of a celebrity).</span></li><li value="2" class="calibre_39"><span class="calibre4">The </span><span class="calibre4"><span class="italic">knows</span></span><span class="calibre4"> function is the only way to look up who knows who.</span></li></ol><p class="calibre_66"><a href="index_split_112.html#filepos827323"><span class="italic">jump to question</span></a></p><p class="calibre_51">Let’s start with a simple brute force approach. We can iterate through all possible people, checking if this person is a celebrity. As soon as we find a person who fits the criteria of being a celebrity, we can return this person.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">int findCelebrity(int people) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   for (int i = 0; i &lt; people; i++) {</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">     if (isCelebrity(people, i)) {</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">        return i;</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return -1;</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">boolean isCelebrity(int people, int candidate) {</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">   for (int i = 0; i &lt; people; i++) {</tt></span></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">     if (i != candidate) {</tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">        if (knows(candidate, i) || !knows(i, candidate)) {</tt></span></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">           return false;</tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">        }</tt></span></li><li value="15" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="16" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="17" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return true;</tt></span></li><li value="18" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">This takes O(N<sup class="calibre11"><small class="calibre12">2</small></sup>) time since we are potentially calling knows(a, b) on every pair of people.</p><p class="calibre_1">Let’s see if we can do this faster.</p><p class="calibre_1">Consider a call to knows for two people, x and y. The result of knows(x, y) will either be true or false. What can we conclude from these results?</p><div class="calibre_15"> </div><ul class="calibre_16"><li value="1" class="calibre_29">Suppose knows(x, y) = true. This means that x knows y. In this case, we know that x is not a celebrity. Celebrities can’t know anybody.</li><li value="2" class="calibre_29">Suppose knows(x, y) = false. This means that x does not know y. In this case, we know that y is not a celebrity since everyone must know the celebrity.</li></ul><p class="calibre_1">This gives us a very interesting learning: given two people who are both potential celebrities, we can always eliminate one person as the celebrity.</p><blockquote class="calibre_23">Note: Now is a good time to pause to try to figure out the rest of the solution.</blockquote><p class="calibre_22">If we can always eliminate one person as the celebrity, then we should be able to trim down our list of N people to just one potential celebrity in N-1 calls to knows. At that point, we can then verify that candidate really is the celebrity (since there could be no celebrities) by calling knows again for candidate and every other person.</p><p class="calibre_1">This can be done in two passes:</p><div class="calibre_15"> </div><ol class="calibre_65"><li value="1" class="calibre_29">Find the candidate.</li><li value="2" class="calibre_29">Verify that the candidate is the celebrity.</li></ol><p class="calibre_1">Before diving into the code, let’s think about how we implement the first pass: finding the candidate.</p><p class="calibre_1">We could have a list that we remove people from as they are eliminated. Shifting elements around in a list is time consuming and, frankly, more work than necessary.</p><p class="calibre_1">If we imagine our calls to knows, we can think about our algorithm as kicking things off with 0 as the candidate. When we call knows(0, 1), we will either eliminate 0 or 1. If we eliminate 0, then candidate becomes 1. We then move on to knows(candidate, 2).</p><p class="calibre_1">Step 2 uses the same isCelebrity method that we implemented earlier.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">int findCelebrity(int people) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   int candidate = findCandidate(people);</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">   if (isCelebrity(people, candidate)) {</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">     return candidate;</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return -1;</tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li><li value="8" class="calibre_60"><br class="calibre1"/></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">int findCandidate(int people) {</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">   int candidate = 0;</tt></span></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">   for (int i = 0; i &lt; people; i++) {</tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">     /* If candidate gets ruled out, move on to i.*/</tt></span></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">     if (knows(candidate, i)) {</tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">        candidate = i;</tt></span></li><li value="15" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="16" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="17" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return candidate;</tt></span></li><li value="18" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li><li value="19" class="calibre_60"><br class="calibre1"/></li><li value="20" class="calibre_60"><span class="calibre5"><tt class="calibre10">boolean isCelebrity(int people, int candidate) {</tt></span></li><li value="21" class="calibre_60"><span class="calibre5"><tt class="calibre10">   for (int i = 0; i &lt; people; i++) {</tt></span></li><li value="22" class="calibre_60"><span class="calibre5"><tt class="calibre10">     if (i != candidate) {</tt></span></li><li value="23" class="calibre_60"><span class="calibre5"><tt class="calibre10">        if (knows(candidate, i) || !knows(i, candidate)) {</tt></span></li><li value="24" class="calibre_60"><span class="calibre5"><tt class="calibre10">           return false;</tt></span></li><li value="25" class="calibre_60"><span class="calibre5"><tt class="calibre10">        }</tt></span></li><li value="26" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="27" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="28" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return true;</tt></span></li><li value="29" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">This algorithm takes O(N) time.</p><p class="calibre_30"><span class="calibre4"><span class="bold">16.22</span></span><span class="calibre4"> You have an NxN matrix of characters and a list of valid words (provided in any format you wish). A word can be formed by starting with any character and then moving up, down, left, or right. Words do not have to be in a straight line (</span><a id="filepos979374"></a><span class="calibre4"><span class="italic">PACKING</span></span><span class="calibre4"> is a word below). You cannot reuse a letter for the same word, so </span><span class="calibre4"><span class="italic">GOING</span></span><span class="calibre4"> (in the grid below) would not be a word since it reuses the G. Design an algorithm and write code to print all valid words. </span></p><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">L I G O</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">E P N I</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">N A C K</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">S M A R</tt></span></blockquote><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><p class="calibre_64"><a href="index_split_112.html#filepos828070"><span class="italic">jump to question</span></a></p><p class="calibre_51">Let’s think about this algorithm step by step. We need to find all words that start with each letter. We can just iterate through each letter on the grid, kicking off a search for words that start with each letter.</p><p class="calibre_1">But how do we find all words that start with a particular letter, like P?</p><p class="calibre_1">From P, we can move either up, down, left, or right. This means that we can think about all words that start with P in the grid as being:</p><blockquote class="calibre_23"><span class="calibre6"><tt class="calibre10">all words that start with P =</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">       all words that start with PI</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">     + all words that start with PE</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">     + all words that start with PA</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">     + all words that start with PN</tt></span></blockquote><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><p class="calibre_31">This leads to a natural recursive algorithm. We recurse in each direction (up, down, left, and right), building a word as we go. Whenever we have a complete word, we print it and continue with the recursion.</p><p class="calibre_1">One tricky part is how we prevent ourselves from reusing a letter for the same word. There are a number of solutions for this, but all take the same general approach of marking a character as being “in use” while we traverse down its path. Afterwards, we unmark it so we can use it again.</p><p class="calibre_1">We have used a boolean array to do this. Before we traverse to a cell’s neighbors, we mark this cell as being taken. After we’re done, we mark it as available again.</p><p class="calibre_1">We can also perform an optimization in short circuiting early in our recursion. Imagine we have built the string PNCKR. That’s certainly not the start of any valid word in our dictionary, so why continue recursing down this path?</p><p class="calibre_1">If we implement the dictionary as a trie, we can have a function that tells us if a string is a substring of a valid word in the dictionary. A trie is special type of tree generally used for storing lists of words. It gives very efficient runtime to call an isPrefix method.</p><p class="calibre_1">For this algorithm, we can use isPrefix to terminate the recursion if we are on an invalid string.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">/* Find all words on board by finding all words that start with each character on the board.*/</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">void boggle(char[][] board) {</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">   boolean[][] marked = new boolean[board.length][board[0].length];</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">   for (int i = 0; i &lt; board.length; i++) {</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">     for (int j = 0; j &lt; board[0].length; j++) {</tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">        boggle(board, i, j, “”, marked);</tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li><li value="10" class="calibre_60"><br class="calibre1"/></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">/* Find all words that start with prefix and use the character at row, col.*/</tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">void boggle(char[][] board, int row, int col, String prefix, boolean[][] marked) {</tt></span></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Check that char is on board and not currently in use.*/</tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">   if (!inBounds(board, row, col) || marked[row][col]) {</tt></span></li><li value="15" class="calibre_60"><span class="calibre5"><tt class="calibre10">     return;</tt></span></li><li value="16" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="17" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="18" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Append character to current word.*/</tt></span></li><li value="19" class="calibre_60"><span class="calibre5"><tt class="calibre10">   prefix = prefix + board[row][col];</tt></span></li><li value="20" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="21" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* If there are no words starting with this prefix, return.*/</tt></span></li><li value="22" class="calibre_60"><span class="calibre5"><tt class="calibre10">   if (!isValidPrefix(prefix)) {</tt></span></li><li value="23" class="calibre_60"><span class="calibre5"><tt class="calibre10">     return;</tt></span></li><li value="24" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="25" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="26" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Found a word. Print it.*/</tt></span></li><li value="27" class="calibre_60"><span class="calibre5"><tt class="calibre10">   if (isValidWord(prefix)) {</tt></span></li><li value="28" class="calibre_60"><span class="calibre5"><tt class="calibre10">     System.out.println(prefix);</tt></span></li><li value="29" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="30" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="31" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Mark character as in use.*/</tt></span></li><li value="32" class="calibre_60"><span class="calibre5"><tt class="calibre10">   marked[row][col] = true;</tt></span></li><li value="33" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="34" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* Traverse each of its neighbors.*/</tt></span></li><li value="35" class="calibre_60"><span class="calibre5"><tt class="calibre10">   boggle(board, row - 1, col, prefix, marked); // Go up</tt></span></li><li value="36" class="calibre_60"><span class="calibre5"><tt class="calibre10">   boggle(board, row, col + 1, prefix, marked); // Go right</tt></span></li><li value="37" class="calibre_60"><span class="calibre5"><tt class="calibre10">   boggle(board, row + 1, col, prefix, marked); // Go down</tt></span></li><li value="38" class="calibre_60"><span class="calibre5"><tt class="calibre10">   boggle(board, row, col - 1, prefix, marked); // Go left</tt></span></li><li value="39" class="calibre_60"><span class="calibre5"><tt class="calibre10">   </tt></span><br class="calibre1"/></li><li value="40" class="calibre_60"><span class="calibre5"><tt class="calibre10">   /* We are done traversing its neighbors and will now return to its parent. Mark this cell as available again.*/</tt></span></li><li value="41" class="calibre_60"><span class="calibre5"><tt class="calibre10">   marked[row][col] = false;</tt></span></li><li value="42" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li><li value="43" class="calibre_60"><br class="calibre1"/></li><li value="44" class="calibre_60"><span class="calibre5"><tt class="calibre10">/* Check if row, col is in bounds.*/</tt></span></li><li value="45" class="calibre_60"><span class="calibre5"><tt class="calibre10">boolean inBounds(char[][] board, int row, int col) {</tt></span></li><li value="46" class="calibre_60"><span class="calibre5"><tt class="calibre10">   if (row &lt; 0 || col &lt; 0 || row &gt;= board.length || col &gt;= board[row].length) {</tt></span></li><li value="47" class="calibre_60"><span class="calibre5"><tt class="calibre10">     return false;</tt></span></li><li value="48" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="49" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return true;</tt></span></li><li value="50" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">Describing the runtime of this algorithm is a bit tricky because it really depends on what the board and the English language is like. If many paths are valid (that is, the words form valid prefixes), then it will be much slower than if a lot of paths are not valid.</p><p class="calibre_1">If we didn’t do the isPrefix check, we would traverse through N<sup class="calibre11"><small class="calibre12">2</small></sup> characters, For each character, we would move in four possible directions the first time and three after that. A path could be as long as N<sup class="calibre11"><small class="calibre12">2</small></sup> (the number of characters), so the number of all possible paths starting from a given character is O(4*3<sup class="calibre11"><small class="calibre12">(N^2)</small></sup>). This give us a time of O(N<sup class="calibre11"><small class="calibre12">2</small></sup>*4*3<sup class="calibre11"><small class="calibre12">(N^2)</small></sup>), which reduces to O(N<sup class="calibre11"><small class="calibre12">2</small></sup>*3<sup class="calibre11"><small class="calibre12">(N^2</small></sup><sup class="calibre11"><small class="calibre12">)</small></sup>).</p><p class="calibre_1">Realistically, given the trie and the pattern of letters in the English language, it will be much faster than that.</p><p class="calibre_30"><span class="calibre4"><span class="bold">16.23</span></span><span class="calibre4"> Given an array of integers (with both positive and negative values), find the contiguous sequence with the largest sum. Return just the sum.</span><a id="filepos990631"></a><br class="calibre1"/><span class="calibre4">
</span><br class="calibre1"/><span class="calibre4"> Example:</span><br class="calibre1"/><span class="calibre4"> Input: 2, -8, 3, -2, 4, -10</span><br class="calibre1"/><span class="calibre4"> Output: 5 (i.e., {3, -2, 4})</span></p><p class="calibre_66"><a href="index_split_112.html#filepos829320"><span class="italic">jump to question</span></a></p><p class="calibre_51">Let’s start off with a brute force and see how we can optimize it.</p><p class="calibre_1"><span class="calibre4"><span class="bold">Brute Force</span></span></p><p class="calibre_14">We could iterate through all possible subsequences, comparing their sum to a maximum sum. At the end, we return the biggest we have seen.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">int getMaxSum(int[] a) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   int maxSum = 0;</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">   for (int left = 0; left &lt; a.length; left++) {</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">     for (int right = left + 1; right &lt; a.length; right++) {</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">        int sum = 0;</tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">        </tt></span><br class="calibre1"/></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">        /* Add all values between */</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">        for (int i = left; i &lt;= right; i++) {</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">           sum += a[i];</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">        }</tt></span></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">        </tt></span><br class="calibre1"/></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">        if (sum &gt; maxSum) {</tt></span></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">           maxSum = sum;</tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">        }</tt></span></li><li value="15" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="16" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="17" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return maxSum;</tt></span></li><li value="18" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li><li value="19" class="calibre_60"><br class="calibre1"/></li></ol><p class="calibre_31">This is O(N<sup class="calibre11"><small class="calibre12">3</small></sup>). We can do better!</p><p class="calibre_1"><span class="calibre4"><span class="bold">Brute Force (Optimized)</span></span></p><p class="calibre_14">Since each subsequence can be uniquely described with a start point and end point, we know that there are roughly O(N<sup class="calibre11"><small class="calibre12">2</small></sup>) subsequences of an array. And yet, our earlier algorithm is taking O(N<sup class="calibre11"><small class="calibre12">3</small></sup>) time. This suggests we might be able to optimize this.</p><p class="calibre_1">Let’s consider what the innermost for loop (the i loop) is doing. It’s just computing the sum of all the elements between left and right. We have just finished computing (in the prior iteration of the right loop) the sum of everything between left and right - 1.</p><p class="calibre_1">Instead of recomputing the sum every time, we can just keep a running sum. When right goes to the next iteration, we just add a[right] to the running sum.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">int getMaxSumBF(int[] a) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   int maxSum = 0;</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">   for (int left = 0; left &lt; a.length; left++) {</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">     int runningSum = 0;</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">     for (int right = left; right &lt; a.length; right++) {</tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">        runningSum += a[right];</tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">        if (runningSum &gt; maxSum) {</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">           maxSum = runningSum;</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">        }</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return maxSum;</tt></span></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">We’re now down to O(N<sup class="calibre11"><small class="calibre12">2</small></sup>) time. This is better, but we’re still essentially doing a brute force solution.</p><p class="calibre_1"><span class="calibre4"><span class="bold">Optimized</span></span></p><p class="calibre_14">Let’s inspect what this last solution did at a deeper level.</p><blockquote class="calibre_23"><span class="calibre6">2, -4, 4, -3, 2, 5, -1, -4, -5, -2, -1, 2</span></blockquote><p class="calibre_31">We moved through all possible subsequences. That includes, for example, subsequences that include the first two values (2 and -4). Why would we ever want a subsequence that starts with {2, -4}? Their sum is -2, which means that they will only make a subsequence’s sum smaller.</p><p class="calibre_1">We <span class="italic">do</span> sometimes want negative values in the subsequence, but only when the negative value can join bigger values on both sides.</p><p class="calibre_1">This leads us to a useful insight: whenever a subsequence is negative, we know we won’t want to include it.</p><p class="calibre_1">Let’s fix up our code to break early when runningSum goes negative, so that we can then try the next value of left.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">int getMaxSum(int[] a) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   int maxSum = 0;</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">   for (int left = 0; left &lt; a.length; left++) {</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">     int runningSum = 0;</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">     for (int right = left; right &lt; a.length; right++) {</tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">        runningSum += a[right];</tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">        if (runningSum &gt; maxSum) {</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">           maxSum = runningSum;</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">        } else if (runningSum &lt; 0) {</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">           break;</tt></span></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">        }</tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">     return maxSum;</tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="15" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">With this change, we now break as soon as we get past {2, -4}. Left will move on to point to -4, and then to 4 after that.</p><p class="calibre_1">We’ll continue moving right until runningSum becomes negative. When runningSum is bigger than maxSum, we’ll update maxSum.</p><p class="calibre_1">When does runningSum become negative? Let’s walk through it.</p><blockquote class="calibre_23"><span class="calibre6"><tt class="calibre10">left:       4</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">right:      4 | -3 | 2 | 5 | -1 | -4 | -5 | ...</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">runningSum: 4 |  1 | 3 | 8 |  7 |  3 | -2 |</tt></span></blockquote><blockquote class="calibre_5"><span class="calibre6"><tt class="calibre10">maxSum:              8</tt></span></blockquote><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><p class="calibre_31">We break when right is pointing to -5. We have now definitely found the largest subsequence that starts at left.</p><p class="calibre_1">Observe that, up until that point, the sum of the values between left and any point x was greater than or equal to 0. In other words:</p><blockquote class="calibre_23"><span class="calibre6"><tt class="calibre10">sum(array[left], array[left + 1], ..., array[x-1]) &gt; 0</tt></span></blockquote><p class="calibre1" style="margin:0pt; border:0pt; height:1em"> </p><p class="calibre_31">Imagine a subsequence starting at x and continue to anywhere in the array. If sum(array[left], array[left + 1], ..., array[x-1]) &gt; 0, then any subsequence starting at x could be made larger by instead starting it at left. It is, therefore, less optimal to start at x.</p><p class="calibre_1">Thus, we haven’t just found the largest subsequence that starts at left. We’ve found the largest subsequence that starts <span class="italic">anywhere</span> between left and right.</p><p class="calibre_1">We should now just move left over to right + 1.</p><p class="calibre_1">This brings us to a new algorithm:</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_39"><span class="calibre4">Start left and right at the far left side.</span></li><li value="2" class="calibre_39"><span class="calibre4">Move right until runningSum becomes negative. </span><ul class="calibre_67"><li value="1" class="calibre_29">Track runningSum and maxSum along the way.</li></ul></li><li value="3" class="calibre_68"><span class="calibre4">When runningSum becomes negative, move left over to right + 1 and reset runningSum.</span></li></ol><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">int getMaxSum(int[] a) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   int maxSum = 0;</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">   int runningSum = 0;</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">   int left = 0;</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">   for (int right = 0; right &lt; a.length; right++) {</tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">     runningSum += a[right];</tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">     if (runningSum &lt; 0) {</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">        left = right + 1;</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">        runningSum = 0;</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">     if (maxSum &lt; runningSum) {</tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">        maxSum = runningSum;</tt></span></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="14" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="15" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return maxSum;</tt></span></li><li value="16" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_1">If you look carefully, you might notice that left is set but never actually used. Therefore, we can implement the code without it.</p><div class="calibre_15"> </div><ol class="calibre_38"><li value="1" class="calibre_60"><span class="calibre5"><tt class="calibre10">int getMaxSum(int[] a) {</tt></span></li><li value="2" class="calibre_60"><span class="calibre5"><tt class="calibre10">   int maxSum = 0;</tt></span></li><li value="3" class="calibre_60"><span class="calibre5"><tt class="calibre10">   int runningSum = 0;</tt></span></li><li value="4" class="calibre_60"><span class="calibre5"><tt class="calibre10">   for (int right = 0; right &lt; a.length; right++) {</tt></span></li><li value="5" class="calibre_60"><span class="calibre5"><tt class="calibre10">     runningSum += a[right];</tt></span></li><li value="6" class="calibre_60"><span class="calibre5"><tt class="calibre10">     if (maxSum &lt; runningSum) {</tt></span></li><li value="7" class="calibre_60"><span class="calibre5"><tt class="calibre10">        maxSum = runningSum;</tt></span></li><li value="8" class="calibre_60"><span class="calibre5"><tt class="calibre10">     } else if (runningSum &lt; 0) {</tt></span></li><li value="9" class="calibre_60"><span class="calibre5"><tt class="calibre10">        runningSum = 0;</tt></span></li><li value="10" class="calibre_60"><span class="calibre5"><tt class="calibre10">     }</tt></span></li><li value="11" class="calibre_60"><span class="calibre5"><tt class="calibre10">   }</tt></span></li><li value="12" class="calibre_60"><span class="calibre5"><tt class="calibre10">   return maxSum;</tt></span></li><li value="13" class="calibre_60"><span class="calibre5"><tt class="calibre10">}</tt></span></li></ol><p class="calibre_31">At this point, we know that we’re done optimizing. This code runs in O(N) time and computes the longest sequence in a single pass of the array. We can’t do better than that.</p><div class="mbp_pagebreak" id="calibre_pb_113"></div>
</body></html>
